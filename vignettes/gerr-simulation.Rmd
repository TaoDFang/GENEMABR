---
title: "Gene-set enrichment with regularized regression: simulation studies"
author: "Jitao David Zhang and Tao Fang"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  BiocStyle::pdf_document:
    toc: true
vignette: >
    %\VignetteIndexEntry{simulation studies with gerr}
    %\VignetteEngine{knitr::rmarkdown}
---

# Background

In the manuscript *Gene-set Enrichment with Regularized Regression* (`gerr` in short), we propose using regularized regression to model the relationship between $Y$, a dichotomous dependent variable indicating membership of genes in a set of genes of interest (GOI hereafter), and $\Omega$, a matrix of dichotomous variables indicating membership of genes in gene-sets that are potentially overlapping or even identical with each other.

In this document, we perform simulation studies to demonstrate the sensitivity and specificity of the `gerr` method, using the software package of the same name that we published along with the manuscript and the elastic net implemented in the R software package `glmnet`. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message=FALSE,
                      fig.width=5, fig.height=5)
library(gerr) 
library(glmnet)
library(msigdbr)
library(MASS)
set.seed(1887)
```  

```{r fromRibiosUtils, echo=FALSE, include=FALSE}
pairwiseDist <- function(list, fun=jaccardIndex) {
  len <- length(list)
  res <- matrix(0, len, len)
  colnames(res) <- rownames(res) <- names(list)
  vals <- sapply(seq(from = 1, to = len - 1), function(i) {
    sapply(seq(from = i + 1, to = len), function(j) {
      do.call(fun, list(list[[i]], list[[j]]))
    })
  })
  vv <- unlist(vals)
  res[lower.tri(res)] <- vv
  res <- t(res) + res
  diag(res) <- do.call(fun, list(list[[1]], list[[1]]))
  return(res)
}
overlapCoefficient <- function(x,y, checkUniqueNonNA=FALSE) {
  if(checkUniqueNonNA) {
    x <- uniqueNonNA(x)
    y <- uniqueNonNA(y)
  }
  res <- length(intersect(x,y))/pmin(length(x), length(y))
  return(res)
}
pairwiseOverlapCoefficient <- function(list) {
  return(pairwiseDist(list, fun=overlapCoefficient))
}
```

# Data used for simulation

We wish to use real-world gene-sets that are commonly used by the community for the simulation study for `gerr`, because synthesized gene-sets may have distributions of sizes, defined by the number of unique genes and overlapping patterns that depart from real-world gene-sets. Therefore we decided to use curated gene-sets provided by the MSigDB database (Category `C2`) for this purpose. These gene-sets are curated from online pathway databases, publications in PubMed, and collected knowledge of domain experts. Therefore they are not structured in tree structures like gene-sets from Gene Ontology (GO) or from the Reactome pathway database. 

```{r gmt}
simTibble <- msigdbr::msigdbr(species="Homo sapiens",
                             category = c("C2"))
simGenesAll <- with(simTibble, tapply(human_gene_symbol, gs_name, unique))
simGenesets <- sample(simGenesAll, 500)
simLen <- sapply(simGenesets, function(x) length(x))
```

The gene-sets are retrieved using the `msigdbr` package. For the purpose of simulation, we randomly sample 500 gene-sets from all gene-sets of the category C2 (N=`r length(simGenesets)`). The histogram below shows the distribution of gene-set size in the sub-sampled set of gene-sets.

```{r sizeDist}
{
  hist(simLen, xlab="Number of unique genes", 
       breaks=50, freq = FALSE,
       col="lightblue", main="Gene-set size distribution")
  lines(density(simLen, from=0), col="#004495", lwd=2)
}
```

Next, we investigate the degree of redundancy among these gene-sets. We use the overlap coefficient, defined by $|A \cap B|/min(|A|,|B|)$ between two sets $A$ and $B$, to measure this.

```{r overlapDist}
simPairwiseOverlap <- pairwiseOverlapCoefficient(simGenesets)
utOver <- simPairwiseOverlap[upper.tri(simPairwiseOverlap, diag=FALSE)]
{
  hist(utOver, xlab="Pairwise overlapping cofficient between gene-sets", 
       breaks=50, freq = FALSE,
       col="orange", 
       main="Overlapping coefficient distribution")
  lines(density(utOver, from=0), col="red", lwd=2)
}
```

```{r overlapStat, include=FALSE}
nonZeroOverlap <- mean(utOver!=0)
nonZeroUts <- utOver[utOver!=0]
nzutMed <- median(nonZeroUts)
nzutMad <- mad(nonZeroUts)
nzutPos <- mean(nonZeroUts>0.5)
```

We calculated the overlap coefficient for all unique pairs of gene-sets, and its distribution is shown in the histogram above. While no overlapping genes are identified between 69.8% pairs of gene-sets, overlapping genes are found in 30.2% pairs of gene-sets, with an median overlap coeffiecient of 0.047 and median absolute deviation (MAD) of 0.035. In about 0.5% of the cases, the overlap coefficient is equal or larger than 0.5. It suggests that while the assumption of independence between gene-sets may hold true when few gene-sets are used, there will be violation when many gene-sets are used for testing. 
# Model verification

We first verify that gene-set enrichment with regularized regression (`gerr`) performs as expected using the simplest simulation that is possible: we assign genes of one gene-set as GOI, and test whether we can recover the gene-set using `gerr`.

First we convert the gene-sets into gene-pathway matrix required by `gerr::regression_selected_pathways`.

```{r gsMatrix}
bgGenes <- unique(unlist(simGenesets))
gsMatrix <- Matrix(sapply(simGenesets, function(x) as.integer(bgGenes %in% x)),
                   sparse=TRUE,
                   dimnames=list(bgGenes, names(simGenesets)))
```

In the code chunk below, we verify that the model works in the sense that the gene-set that is used as source of GOI is correctly recovered, using randomly selected 10 gene-sets.

```{r smallVeri}
selInd <- sample(seq(along=simGenesets), 10)
selGsName <- names(simGenesets)[selInd]
selGs <- simGenesets[selInd]
selRes <- lapply(selGs, function(gs)
  regression_selected_pathways(gene_input=gs, gene_pathway_matrix = gsMatrix))
foundCounts <- sapply(seq(along=selInd), 
                      function(i) length(selRes[[i]][[1]]))
isRecovered <- sapply(seq(along=selInd), 
                      function(i) selGsName[i] %in% names(selRes[[i]][[1]]))
stopifnot(all(isRecovered))
table(foundCounts)
```

The `foundCounts` variable indicates the number of gene-sets whose coeffient is positive. In this particular example, we have 8 cases where only one gene-set is selected, and thanks to the observation that the input gene-set is all recovered (`isRecovered` is all true), the selected gene-set by `gerr` must be the input geneset.

There are two cases where two gene-sets are returned. The code below examine how the selected gene-sets are related.

```{r moreThanOneSel}
mt1Return <- foundCounts>1
mt1ReturnOverlapCoef <- sapply(which(mt1Return), function(i) {
  selGnames <- names(selRes[[i]]$selected_pathways_names)
  poe <- pairwiseOverlapCoefficient(simGenesets[selGnames])
  mean(poe[upper.tri(poe, diag=FALSE)])
})
print(mt1ReturnOverlapCoef)
```

It turns out in both cases, the selected gene-sets (one of which is the input gene-set) are partially redudant, with an overlap coefficient higher than 0.5. This makes sense because when two dependent variables are similarly correlated with the target variable, they are given similar weights by the elastic net.

Below we run the simulation for all gene-sets. This is not executed by default because of running time (about six minutes in a Linux in Virtual environment with 4G memory and one core Intel i5 CPU), but the idea is the same as the small verification step above.

```{r verificateAll, eval=FALSE}
verificate <- function(genesets, gsMatrix, index) {
  stopifnot(index %in% seq(along=genesets))
  selGsName <- names(genesets)[index]
  selGs <- genesets[index]
  selRes <- lapply(selGs, function(gs) {
    regression_selected_pathways(gene_input=gs, gene_pathway_matrix = gsMatrix)
  })
  selInd <- sapply(seq(along=index), 
                        function(i) selRes[[i]][[1]])
  isRecovered <- sapply(seq(along=index), 
                        function(i) selGsName[i] %in% names(selRes[[i]][[1]]))
  res <- list(results=selRes, selInd=selInd, isRecovered=isRecovered)
  return(res)
}
system.time(verifRes <- verificate(simGenesets, gsMatrix, index=seq(along=simGenesets)))
summary(verifRes$isRecovered) ## all recovered
verifSelCount <- sapply(verifRes$selInd, length)
summary(verifSelCount>1) ## in 44 cases of 500 gene-sets, more than one gene-set was selected
verifMt1AvgOe <- sapply(which(verifSelCount>1), function(i) {
  selGnames <- names(verifRes$results[[i]]$selected_pathways_names)
  poe <- pairwiseOverlapCoefficient(simGenesets[selGnames])
  mean(poe[upper.tri(poe, diag=FALSE)])
})
```

We verify that all gene-sets that were assigned as genes of interest was successfully recovered. Int 44 out of 500 gene-sets, more than one gene-set was selected by `gerr`. The average pairwise overlap coefficient between multiple selected genesets is quite high (median 0.86, MAD 0.123). It suggests that `gerr` is able to identify gene-sets that are highly enriched among many gene-sets.

# Simulations for specificity testing
# Simulations for sensitivity testing

# R session info

```{r session}
sessionInfo()
```
